<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ToF Material Mask Generator</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-color: #2d2d2d;
            --text-color: #e0e0e0;
            --accent-color: #007acc;
        }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        #sidebar {
            width: 300px;
            background-color: var(--panel-color);
            padding: 20px;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
        }
        #main {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            background-image: 
                linear-gradient(45deg, #222 25%, transparent 25%), 
                linear-gradient(-45deg, #222 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #222 75%),
                linear-gradient(-45deg, transparent 75%, #222 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        canvas {
            border: 1px solid #000;
            image-rendering: pixelated;
            max-width: 90%;
            max-height: 90vh;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label { font-size: 0.9em; color: #888; }
        input[type="file"], input[type="range"], select {
            width: 100%;
        }
        button {
            padding: 10px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover { opacity: 0.9; }
        .label-list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 5px;
        }
        .label-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid transparent;
        }
        .label-item.active {
            background-color: #3e3e3e;
            border-color: var(--accent-color);
        }
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }
        #info-panel {
            font-size: 0.8em;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 4px;
        }
        .status {
            font-size: 0.8em;
            color: #aaa;
        }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>Mask Generator</h2>
    
    <div class="control-group">
        <label>1. RecInfo.jsonを選択</label>
        <input type="file" id="jsonInput" accept=".json">
    </div>
    
    <div class="control-group">
        <label>2. RecImage_*.rawを選択</label>
        <input type="file" id="rawInput" accept=".raw">
    </div>

    <div id="info-panel">
        <div>Resolution: <span id="res-val">-</span></div>
        <div>Frames in file: <span id="frames-val">-</span></div>
    </div>

    <hr style="width:100%; border:0; border-top:1px solid #444;">

    <div class="control-group">
        <label>フレーム選択</label>
        <input type="range" id="frameSlider" min="0" max="0" value="0">
        <div class="status">Frame: <span id="current-frame">0</span></div>
    </div>

    <div class="control-group">
        <label>表示モード</label>
        <select id="viewMode">
            <option value="ir">Infrared (IR)</option>
            <option value="depth">Depth</option>
        </select>
    </div>

    <div class="control-group">
        <label>ブラシサイズ: <span id="brush-size-val">10</span>px</label>
        <input type="range" id="brushSize" min="1" max="50" value="10">
    </div>

    <div class="control-group">
        <label>材質ラベル</label>
        <div class="label-list" id="labelList">
            <div class="label-item active" data-id="0">
                <div class="color-box" style="background-color: #ff0000;"></div>
                <span>0: Metal</span>
            </div>
            <div class="label-item" data-id="1">
                <div class="color-box" style="background-color: #00ff00;"></div>
                <span>1: Wood</span>
            </div>
            <div class="label-item" data-id="2">
                <div class="color-box" style="background-color: #0000ff;"></div>
                <span>2: Plastic</span>
            </div>
            <div class="label-item" data-id="3">
                <div class="color-box" style="background-color: #ffff00;"></div>
                <span>3: Fabric</span>
            </div>
            <div class="label-item" data-id="4">
                <div class="color-box" style="background-color: #ff00ff;"></div>
                <span>4: Wax</span>
            </div>
            <div class="label-item" data-id="255">
                <div class="color-box" style="background-color: #000; border: 1px solid #444;"></div>
                <span>Eraser (Void)</span>
            </div>
        </div>
    </div>

    <button id="saveBtn">マスクを保存 (PNG)</button>
    <div class="status">保存名: frame_XXXX_mask.png</div>
</div>

<div id="main">
    <!-- レイヤー構造: 背景画像 + マスク画像(半透明) -->
    <canvas id="viewCanvas"></canvas>
    <canvas id="maskCanvas" style="position: absolute; top: auto; left: auto; opacity: 0.6; cursor: crosshair;"></canvas>
</div>

<script>
    const state = {
        metadata: null,
        rawBuffer: null,
        frameSize: 0,
        numFrames: 0,
        currentFrameIdx: 0,
        width: 640,
        height: 480,
        imageDefs: [],
        currentLabel: 0,
        brushSize: 10,
        isDrawing: false,
        colors: {
            0: '#ff0000',
            1: '#00ff00',
            2: '#0000ff',
            3: '#ffff00',
            4: '#ff00ff',
            255: 'rgba(0,0,0,0)'
        }
    };

    const viewCanvas = document.getElementById('viewCanvas');
    const maskCanvas = document.getElementById('maskCanvas');
    const vCtx = viewCanvas.getContext('2d');
    const mCtx = maskCanvas.getContext('2d');

    // UI Elements
    const jsonInput = document.getElementById('jsonInput');
    const rawInput = document.getElementById('rawInput');
    const frameSlider = document.getElementById('frameSlider');
    const currentFrameSpan = document.getElementById('current-frame');
    const resValSpan = document.getElementById('res-val');
    const framesValSpan = document.getElementById('frames-val');
    const brushSizeSlider = document.getElementById('brushSize');
    const brushSizeValSpan = document.getElementById('brush-size-val');
    const viewModeSelect = document.getElementById('viewMode');
    const labelItems = document.querySelectorAll('.label-item');
    const saveBtn = document.getElementById('saveBtn');

    // --- File Loading ---

    jsonInput.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const text = await file.text();
        state.metadata = JSON.parse(text);
        
        state.imageDefs = state.metadata.Images || [];
        state.frameSize = 0;
        state.imageDefs.forEach(img => {
            img.bpp_val = img.bpp || 16;
            img.byteSize = img.width * img.height * (img.bpp_val / 8);
            img.offset = state.frameSize;
            state.frameSize += img.byteSize;
            
            // 解像度設定（最初の画像から）
            if (state.frameSize === img.byteSize) {
                state.width = img.width;
                state.height = img.height;
            }
        });

        resValSpan.textContent = `${state.width} x ${state.height}`;
        initCanvases();
        updateInfo();
    };

    rawInput.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file || !state.metadata) return;
        const buffer = await file.arrayBuffer();
        state.rawBuffer = buffer;
        state.numFrames = Math.floor(buffer.byteLength / state.frameSize);
        
        frameSlider.max = state.numFrames - 1;
        frameSlider.value = 0;
        framesValSpan.textContent = state.numFrames;
        
        loadFrame(0);
    };

    function initCanvases() {
        viewCanvas.width = state.width;
        viewCanvas.height = state.height;
        maskCanvas.width = state.width;
        maskCanvas.height = state.height;
        
        // マスクを透明で初期化
        mCtx.clearRect(0, 0, state.width, state.height);
        
        // 位置合わせ
        const rect = viewCanvas.getBoundingClientRect();
        maskCanvas.style.width = rect.width + 'px';
        maskCanvas.style.height = rect.height + 'px';
    }

    // --- Rendering ---

    function loadFrame(idx) {
        if (!state.rawBuffer) return;
        state.currentFrameIdx = idx;
        currentFrameSpan.textContent = idx;
        
        const offset = idx * state.frameSize;
        const frameData = state.rawBuffer.slice(offset, offset + state.frameSize);
        
        renderView(frameData);
    }

    function renderView(buffer) {
        const mode = viewModeSelect.value;
        const imgDef = state.imageDefs.find(img => img.kind.toLowerCase().includes(mode)) || state.imageDefs[0];
        
        if (!imgDef) return;

        const view = new DataView(buffer, imgDef.offset, imgDef.byteSize);
        const imgData = vCtx.createImageData(state.width, state.height);
        
        let maxVal = 0;
        const pixels = new Uint16Array(imgDef.width * imgDef.height);
        for (let i = 0; i < pixels.length; i++) {
            pixels[i] = view.getUint16(i * 2, true);
            if (pixels[i] > maxVal && pixels[i] < 65535) maxVal = pixels[i];
        }

        if (maxVal === 0) maxVal = 1000;

        for (let i = 0; i < pixels.length; i++) {
            let val = pixels[i];
            let r, g, b;

            if (mode === 'ir') {
                const norm = Math.min(255, (val / maxVal) * 255);
                r = g = b = norm;
            } else {
                // Depth: Simple JET-like colormap
                const norm = Math.min(1, val / 4000); // 4m max
                if (val === 0 || val > 10000) {
                    r = g = b = 0;
                } else {
                    r = Math.floor(255 * (1 - norm));
                    g = Math.floor(255 * norm);
                    b = 100;
                }
            }

            const idx = i * 4;
            imgData.data[idx] = r;
            imgData.data[idx + 1] = g;
            imgData.data[idx + 2] = b;
            imgData.data[idx + 3] = 255;
        }

        vCtx.putImageData(imgData, 0, 0);
    }

    // --- Interaction ---

    frameSlider.oninput = (e) => {
        loadFrame(parseInt(e.target.value));
    };

    viewModeSelect.onchange = () => {
        if (state.rawBuffer) loadFrame(state.currentFrameIdx);
    };

    brushSizeSlider.oninput = (e) => {
        state.brushSize = parseInt(e.target.value);
        brushSizeValSpan.textContent = state.brushSize;
    };

    labelItems.forEach(item => {
        item.onclick = () => {
            labelItems.forEach(i => i.classList.remove('active'));
            item.classList.add('active');
            state.currentLabel = parseInt(item.dataset.id);
        };
    });

    // --- Drawing ---

    maskCanvas.onmousedown = (e) => {
        state.isDrawing = true;
        draw(e);
    };

    window.onmouseup = () => {
        state.isDrawing = false;
        mCtx.beginPath();
    };

    maskCanvas.onmousemove = draw;

    function draw(e) {
        if (!state.isDrawing) return;

        const rect = maskCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (state.width / rect.width);
        const y = (e.clientY - rect.top) * (state.height / rect.height);

        mCtx.lineWidth = state.brushSize;
        mCtx.lineCap = 'round';
        
        if (state.currentLabel === 255) {
            mCtx.globalCompositeOperation = 'destination-out';
        } else {
            mCtx.globalCompositeOperation = 'source-over';
            mCtx.strokeStyle = state.colors[state.currentLabel];
        }

        mCtx.lineTo(x, y);
        mCtx.stroke();
        mCtx.beginPath();
        mCtx.moveTo(x, y);
    }

    // --- Saving ---

    saveBtn.onclick = () => {
        // 保存用の隠しキャンバスを作成（アルファ値ではなくインデックス値を持つ画像）
        // ただし、通常のPNGとして視認性を確保するため、現在の色で保存するか、
        // あるいはグレースケール（値=ID）で保存するか。
        // 学習用には 値=ID が必要。
        
        const saveCanvas = document.createElement('canvas');
        saveCanvas.width = state.width;
        saveCanvas.height = state.height;
        const sCtx = saveCanvas.getContext('2d');
        
        // maskCanvasの各ピクセルをスキャンしてIDに変換
        const maskData = mCtx.getImageData(0, 0, state.width, state.height);
        const outData = sCtx.createImageData(state.width, state.height);
        
        // 色 -> ID 逆引きマップ
        const reverseColors = {};
        Object.entries(state.colors).forEach(([id, color]) => {
            if (id == 255) return;
            const r = parseInt(color.slice(1,3), 16);
            const g = parseInt(color.slice(3,5), 16);
            const b = parseInt(color.slice(5,7), 16);
            reverseColors[`${r},${g},${b}`] = parseInt(id);
        });

        for (let i = 0; i < maskData.data.length; i += 4) {
            const r = maskData.data[i];
            const g = maskData.data[i+1];
            const b = maskData.data[i+2];
            const a = maskData.data[i+3];
            
            let id = 0; // デフォルト背景
            if (a > 0) {
                id = reverseColors[`${r},${g},${b}`] ?? 0;
            }
            
            // 保存用：RチャネルにIDを書き込む（モノクロ保存に近いが、視認性は低い）
            // 学習スクリプトは cv2.imread(..., cv2.IMREAD_UNCHANGED) でこの値を読む
            outData.data[i] = id;
            outData.data[i+1] = id;
            outData.data[i+2] = id;
            outData.data[i+3] = 255;
        }
        
        sCtx.putImageData(outData, 0, 0);
        
        const link = document.createElement('a');
        const filename = `frame_${state.currentFrameIdx.toString().padStart(5, '0')}_mask.png`;
        link.download = filename;
        link.href = saveCanvas.toDataURL('image/png');
        link.click();
    };

    function updateInfo() {
        if (!state.metadata) return;
        // その他情報更新
    }

    window.onresize = initCanvases;

</script>

</body>
</html>
